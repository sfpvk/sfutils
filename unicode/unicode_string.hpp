#include <string>
#include <utility>
#include <locale>
#include <tuple>
#include <vector>
#include <utility>
#include <cassert>
#include <type_traits>
#include <concepts>
#include <algorithm>
#include "encoding_cvt.hpp"
#include "base.hpp"


namespace sfpvk::utils::unicode {


template <typename T>
concept Wchar_string = (std::same_as<std::decay_t<
			std::remove_pointer_t<std::decay_t<T>>>, wchar_t>  ||
		std::same_as<typename std::remove_cvref_t<T>::value_type, wchar_t>);

template <typename T>
concept Wchar_std_string = Wchar_string<T>  &&
		!std::same_as<typename std::remove_cvref_t<T>, class Ustring>;

template <typename T>
concept Non_wchar_std_string = !Wchar_string<T>  &&
		!std::same_as<typename std::remove_cvref_t<T>, class Ustring>;

class Ustring
{
	friend void swap(Ustring &l, Ustring &r);
public:
	// Position measured in code points.
	using cpnt_pos = ssize_t;
	// Position measured in chars.
	using chr_pos = ssize_t;
	// r_loc - locale generated by boost::locale::generator,
	// will be stored inside. 
	template <Non_wchar_std_string T>
		Ustring &operator=(T &&str);
	template <Wchar_std_string T>
		Ustring &operator=(T &&str);
	template <Wchar_std_string T>
		Ustring &operator+=(const T &str);
	template <Non_wchar_std_string T>
		Ustring &operator+=(const T &str);
	Ustring &operator+=(const Ustring &str);
	Ustring(const std::locale *r_loc);
	template <typename T>
		Ustring(T &&str, const std::locale *r_loc);
	Ustring(const Ustring &other);
	Ustring(Ustring &&other)noexcept;
	Ustring &operator=(const Ustring &other);
	Ustring &operator=(Ustring &&other)noexcept;
	// Converts the internal string to o_dest.
	template <typename CharT>
		void cvt(std::basic_string<CharT> *o_dest);
	chr_pos ssize_in_chars();
	cpnt_pos ssize_in_codepoints()const;
	// 0 <= pos <= ssize_in_chars().
	// Returns the first code point index of pos character.
	cpnt_pos to_cpntpos(chr_pos pos);
	// 0 <= pos <= ssize_in_codepoints().
	// Retruns the index of character that owns the code point.
	chr_pos to_chrpos(cpnt_pos pos);
	// 0 <= i <= ssize_in_chars(). If i == ssize_in_chars(), then
	// Return {wstring::end(), wstring::end()}.
	std::pair<std::wstring::const_iterator,
			  std::wstring::const_iterator> operator[](chr_pos i);
	void reserve(ssize_t sz);
	void insert(cpnt_pos index, wchar_t ch);
	void insert(cpnt_pos index, const std::wstring &str);
	void push_back(wchar_t c);
	void erase(cpnt_pos first, cpnt_pos end);
	void clear();
	const std::wstring &base_wstring()const &;
	std::wstring &&base_wstring()&&;
private:
	using it_array_t = std::vector<std::pair<std::wstring::const_iterator,
		  std::wstring::const_iterator>>;
	enum markup_e : unsigned char
	{
		e_unmarked   = 0b00,
		e_characters = 0b01
	};
	ssize_t find_pos(const it_array_t &match_ar, cpnt_pos pos);
	void markup(markup_e m);
	std::wstring m_str;
	it_array_t m_chedges;
	const std::locale *m_loc;
	unsigned char m_markup_state;
};

inline void swap(Ustring &l, Ustring &r)
{
	using std::ranges::swap;
	swap(l.m_str, r.m_str);
	swap(l.m_chedges, r.m_chedges);
	swap(l.m_loc, r.m_loc);
	swap(l.m_markup_state, r.m_markup_state);
}

inline ssize_t Ustring::find_pos(const it_array_t &match_ar, cpnt_pos pos)
{
	if (pos == std::ssize(m_str))
		return std::ssize(match_ar);
	auto res = std::ranges::upper_bound(match_ar, pos, {},
			[this](const auto &r) {
				return r.first-m_str.begin();});
	if (res != match_ar.begin())
		-- res;
	return res - match_ar.begin();
}

inline void Ustring::markup(markup_e m)
{
	using namespace boost::locale;
	if (m_markup_state & m)
		return;
	if (m == e_characters) {
		static thread_local boundary::wssegment_index characters;
		characters.map(boundary::character, m_str.begin(), m_str.end(), *m_loc);
		m_chedges.clear();
		m_chedges.reserve(m_str.size());
		auto char_it_end = characters.end();
		for (auto char_it = characters.begin();  char_it != char_it_end;
				++char_it)
			m_chedges.emplace_back(char_it->begin(), char_it->end());
	}
	else {
		assert(false);
	}
	m_markup_state |= m;
}

template <Wchar_std_string T>
Ustring &Ustring::operator=(T &&str)
{
	m_str = std::forward<T>(str);
	m_markup_state = e_unmarked;
	return *this;
}

template <Non_wchar_std_string T>
Ustring &Ustring::operator=(T &&str)
{
	g_cvt_to_wide(str, &m_str, *m_loc);
	return operator=(m_str);
}

template <Wchar_std_string T>
inline Ustring &Ustring::operator+=(const T &str)
{
	m_str += str;
	m_markup_state = e_unmarked;
	return *this;
}

template <Non_wchar_std_string T>
Ustring &Ustring::operator+=(const T &str)
{
	std::wstring buf;
	g_cvt_to_wide(str, &buf, *m_loc);
	return operator+=(buf);
}

inline Ustring &Ustring::operator+=(const Ustring &str)
{
	return operator+=(str.m_str);
}

inline Ustring::Ustring(const std::locale *r_loc) :
	m_loc{r_loc},
	m_markup_state{e_unmarked}
{
}

template <typename T>
Ustring::Ustring(T &&str, const std::locale *r_loc) : Ustring{r_loc}
{
	operator=(std::forward<T>(str));
}

inline Ustring::Ustring(const Ustring &other) :
	Ustring{other.m_str, other.m_loc}
{
}

inline Ustring::Ustring(Ustring &&other)noexcept :
	Ustring{other.m_loc}
{
	swap(*this, other);
}

inline Ustring &Ustring::operator=(const Ustring &other)
{
	Ustring other_new(other);
	swap(*this, other_new);
	return *this;
}

inline Ustring &Ustring::operator=(Ustring &&other)noexcept
{
	swap(*this, other);
	return *this;
}

template <typename CharT>
void Ustring::cvt(std::basic_string<CharT> *o_dest)
{
	o_dest->clear();
	if (! m_str.empty())
		g_cvt_from_wide(m_str, o_dest, *m_loc);
}

inline Ustring::chr_pos Ustring::ssize_in_chars()
{
	markup(e_characters);
	return std::ssize(m_chedges);
}

inline Ustring::cpnt_pos Ustring::ssize_in_codepoints()const
{
	return std::ssize(m_str);
}

inline Ustring::cpnt_pos Ustring::to_cpntpos(chr_pos pos)
{
	markup(e_characters);
	assert(pos <= std::ssize(m_chedges));
	if (pos == std::ssize(m_chedges))
		return std::ssize(m_str);
	return m_chedges[sig(pos)].first - m_str.begin();
}

inline Ustring::chr_pos Ustring::to_chrpos(cpnt_pos pos)
{
	assert(pos <= std::ssize(m_str));
	markup(e_characters);
	return find_pos(m_chedges, pos);
}

inline std::pair<std::wstring::const_iterator,
		std::wstring::const_iterator> Ustring::operator[](chr_pos i)
{
	markup(e_characters);
	assert(i <= std::ssize(m_chedges));
	if (i == std::ssize(m_chedges))
		return {m_str.end(), m_str.end()};
	return m_chedges[sig(i)];
}

inline void Ustring::reserve(ssize_t sz)
{
	m_str.reserve(sig(sz));
	m_markup_state = e_unmarked;
}

inline void Ustring::insert(cpnt_pos index, wchar_t ch)
{
	m_str.insert(index, 1, ch);
	m_markup_state = e_unmarked;
}

inline void Ustring::insert(cpnt_pos index, const std::wstring &str)
{
	if (str.empty())
		return;
	m_str.insert(m_str.begin()+index, str.begin(), str.end());
	m_markup_state = e_unmarked;
}

inline void Ustring::push_back(wchar_t c)
{
	m_str += c;
	m_markup_state = e_unmarked;
}

inline void Ustring::erase(cpnt_pos first, cpnt_pos end)
{
	m_str.erase(m_str.begin()+first, m_str.begin()+end);
	m_markup_state = e_unmarked;
}

inline void Ustring::clear()
{
	m_str.clear();
	m_markup_state = e_unmarked;
}

inline const std::wstring &Ustring::base_wstring()const &
{
	return m_str;
}

inline std::wstring &&Ustring::base_wstring()&&
{
	m_markup_state = e_unmarked;
	return std::move(m_str);
}


} //sfpvk::utils::unicode
